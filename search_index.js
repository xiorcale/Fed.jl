var documenterSearchIndex = {"docs":
[{"location":"client/#Client","page":"Client","title":"Client","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"CurrentModule = Fed.Client","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"The client is a microservice which exposes the infrastructure required to communicate with the server. It is however independent of the machine learning tools. The training loop is defined externally by the user, and then is \"proxied\" by the client.","category":"page"},{"location":"client/#App","page":"Client","title":"App","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Entry point to start a client node. The setup is done automatically on startup and assumes the server is reachable.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"build_router\nstart","category":"page"},{"location":"client/#Fed.Client.build_router","page":"Client","title":"Fed.Client.build_router","text":"build_router(node::Node)\n\nBuild the routes to the node endpoints.\n\n\n\n\n\n","category":"function"},{"location":"client/#Fed.Client.start","page":"Client","title":"Fed.Client.start","text":"start(node::Node)\n\nStart the given node by setting up its router, and registering it to the server.\n\n\n\n\n\n","category":"function"},{"location":"client/#Node","page":"Client","title":"Node","text":"","category":"section"},{"location":"client/","page":"Client","title":"Client","text":"Data structure containing the client's configuration and its API for communicating with the server.","category":"page"},{"location":"client/","page":"Client","title":"Client","text":"Node\nfit_service\nregister_to_server","category":"page"},{"location":"client/#Fed.Client.Node","page":"Client","title":"Fed.Client.Node","text":"Node(host, port, fit, config)\n\nOrchestrate the training on local data of the clients participating in the federated training. A Node is registerating itself to the server on startup, and then wait for server requests for training on its local data.\n\nThe fit function is called \"proxied function\". It should define the training loop and respect the following signature:\n\nfit(weights::Vector{Float32})::Vector{Float32}\n\nWhere weights is a flatten 1D array contianing the model parameters.\n\n\n\n\n\n","category":"type"},{"location":"client/#Fed.Client.fit_service","page":"Client","title":"Fed.Client.fit_service","text":"fit_service(node::Node, request::HTTP.Request)\n\nFit the received weights contained in the request with the node's local data, and return the updated weights to the caller. This function is calling the \"proxied function\" fit from the Node.\n\ninfo: Info\nAPI Endpoint: this is an HTTP client endpoint.\n\n\n\n\n\n","category":"function"},{"location":"client/#Fed.Client.register_to_server","page":"Client","title":"Fed.Client.register_to_server","text":"register_to_server(node::Node)\n\nRegister the node to the server, letting it knows that a node is available to take part in the training.\n\ninfo: Info\nAPI Client: this is an HTTP client request.\n\n\n\n\n\n","category":"function"},{"location":"serde/serde/#Serde","page":"Introduction","title":"Serde","text":"","category":"section"},{"location":"serde/serde/","page":"Introduction","title":"Introduction","text":"CurrentModule = Fed.Serde","category":"page"},{"location":"serde/serde/","page":"Introduction","title":"Introduction","text":"This module exposes different way to (de)serialize the payloads exchanged between the server and the nodes. Excepted the VanillaPayloadSerde, all the other Payloads are making use of various compression schemes to reduce the communication cost.","category":"page"},{"location":"server/#Server","page":"Server","title":"Server","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"CurrentModule = Fed.Server","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"The server is the orchestrator of the training, aggregating the results from the clients to improve the global model. As the clients, it is independent of the machine learning tools. The server can evaluate the global model by proxying an evaluate() function.","category":"page"},{"location":"server/#App","page":"Server","title":"App","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Entry point to start the CentralNode. The server must be started before launching clients.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"build_router\nstart","category":"page"},{"location":"server/#Fed.Server.build_router","page":"Server","title":"Fed.Server.build_router","text":"build_router(central_node::CentralNode)\n\nBuild the routes to the central node endpoints.\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.start","page":"Server","title":"Fed.Server.start","text":"start(central_node::CentralNode)\n\nStart a Fed.jl HTTP server.\n\n\n\n\n\n","category":"function"},{"location":"server/#CentralNode","page":"Server","title":"CentralNode","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"Data structure containing the server's configuration and its API for communicating with the nodes.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"CentralNode\nfit\nfit_client\nfit_clients\nregister_client!","category":"page"},{"location":"server/#Fed.Server.CentralNode","page":"Server","title":"Fed.Server.CentralNode","text":"CentralNode(host, port, weights, strategy, evaluate, config)\n\nOrchestrate the entire federated learning process. It handles the clients registration and requests them to train on their local data.\n\n\n\n\n\n","category":"type"},{"location":"server/#Fed.Server.fit","page":"Server","title":"Fed.Server.fit","text":"fit(central_node::CentralNode)\n\nFit the global model by orchestrating the federated training.\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.fit_client","page":"Server","title":"Fed.Server.fit_client","text":"fit_client(url::String, payload::Vector{UInt8})\n\nAsk one client to train on its local data, by using the model weights contained in the payload. Return the serialized updated weights.\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.fit_clients","page":"Server","title":"Fed.Server.fit_clients","text":"fit_clients(endpoint::String, clients::Vector{String}, payload::Vector{UInt8})\n\nAsk asynchronously each client from clients to train on their local data by using the model weights contained in the payload. Return a Vector where each element is the serialized weights of one client.\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.register_client!","page":"Server","title":"Fed.Server.register_client!","text":"register_client!(cm::ClientManager, req::HTTP.Request)\n\nRegister a new client in the ClientManager. The body of the request should contain the client URL: http://hostname:port.\n\ninfo: Info\nAPI Endpoint: this is an HTTP server endpoint.\n\n\n\n\n\n","category":"function"},{"location":"server/#ClientManager","page":"Server","title":"ClientManager","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"The ClientManager handles the nodes registrations and synchronize the server to make it start when the clients are ready.","category":"page"},{"location":"server/","page":"Server","title":"Server","text":"ClientManager\nlength(::ClientManager)\nnum_available_clients\nregister!\nsample_clients\nwait_for","category":"page"},{"location":"server/#Fed.Server.ClientManager","page":"Server","title":"Fed.Server.ClientManager","text":"ClientManager()\n\nStructure which manages the clients registration and syncrhonizes the server to make it work with them.\n\n\n\n\n\n","category":"type"},{"location":"server/#Base.length-Tuple{Fed.Server.ClientManager}","page":"Server","title":"Base.length","text":"length(cm::ClientManager)\n\nReturn the number of client managed by the ClientManager.\n\n\n\n\n\n","category":"method"},{"location":"server/#Fed.Server.num_available_clients","page":"Server","title":"Fed.Server.num_available_clients","text":"num_available_clients(cm::ClientManager)\n\nReturn the number of available clients.\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.register!","page":"Server","title":"Fed.Server.register!","text":"register!(cm::ClientManager, client_url::String)\n\nRegister a new client_url.\n\nExample\n\nregister!(cm, \"http://127.0.0.1:8081\")\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.sample_clients","page":"Server","title":"Fed.Server.sample_clients","text":"sample_clients(cm::ClientManager, fraction::Float32)\n\nSample randomly fraction% of the clients, without replacement. Return at least one client if the number of available clients > 0.\n\n\n\n\n\n","category":"function"},{"location":"server/#Fed.Server.wait_for","page":"Server","title":"Fed.Server.wait_for","text":"wait_for(cm::ClientManager, num_clients::Int)\n\nBlock until at least num_clients are available.\n\n\n\n\n\n","category":"function"},{"location":"server/#Strategy","page":"Server","title":"Strategy","text":"","category":"section"},{"location":"server/","page":"Server","title":"Server","text":"federated_averaging","category":"page"},{"location":"server/#Fed.Server.federated_averaging","page":"Server","title":"Fed.Server.federated_averaging","text":"federated_averaging(round_weights)\n\nImplement the federated averaging algorithm descibed in:\n\nCommunication-Efficient Learning of Deep Networks from Decentralized Data\n\nround_weights must be an array containing the weights from each clients participating in the round.\n\n\n\n\n\n","category":"function"},{"location":"serde/payloads/#Payloads","page":"Payloads","title":"Payloads","text":"","category":"section"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"CurrentModule = Fed.Serde","category":"page"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"Abstraction for the (de)serialization and (de)compression processes. This gives good capabilities of extensions as implementing the abstraction does not require any other changes in the library to use the new scheme.","category":"page"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"The implemented PayloadSerde are presented below, but first, let's describe the abstraction to implement.","category":"page"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"PayloadSerde\nserialize_payload(::PayloadSerde, ::Vector{Float32})\ndeserialize_payload(::PayloadSerde, ::Vector{UInt8}, ::String)","category":"page"},{"location":"serde/payloads/#Fed.Serde.PayloadSerde","page":"Payloads","title":"Fed.Serde.PayloadSerde","text":"PayloadSerde\n\nInterface to implement for creating a new compression scheme for the payload.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.serialize_payload-Tuple{Fed.Serde.PayloadSerde,Array{Float32,1}}","page":"Payloads","title":"Fed.Serde.serialize_payload","text":"serialize_payload(payload_serde::PayloadSerde, weights::Vector{Float32})\n\nSerialize weights by applying the transformation defined by the  payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#Fed.Serde.deserialize_payload-Tuple{Fed.Serde.PayloadSerde,Array{UInt8,1},String}","page":"Payloads","title":"Fed.Serde.deserialize_payload","text":"deserialize_payload(payload_serde::PayloadSerde, data::Vector{UInt8}, from::String)\n\nDeserialize data by applying the inverse transformation of the serialization process. from is the URL from which the data are coming, which may be an empty string if unused by the payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#VanillaPayloadSerde","page":"Payloads","title":"VanillaPayloadSerde","text":"","category":"section"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"VanillaPayloadSerde\nserialize_payload(::VanillaPayloadSerde, ::Vector{Float32})\ndeserialize_payload(::VanillaPayloadSerde, ::Vector{UInt8}, ::String)","category":"page"},{"location":"serde/payloads/#Fed.Serde.VanillaPayloadSerde","page":"Payloads","title":"Fed.Serde.VanillaPayloadSerde","text":"VanillaPayloadSerde() <: PayloadSerde\n\nBasic serialization where no compression is applied. This PayloadSerde is only a wrapper around the data serialization in order to match the interface to implement.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.serialize_payload-Tuple{Fed.Serde.VanillaPayloadSerde,Array{Float32,1}}","page":"Payloads","title":"Fed.Serde.serialize_payload","text":"serialize_payload(::VanillaPayloadSerde, weights)\n\nSerialize weights with the VanillaPayloadSerde where only basic serialization is applied.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#Fed.Serde.deserialize_payload-Tuple{Fed.Serde.VanillaPayloadSerde,Array{UInt8,1},String}","page":"Payloads","title":"Fed.Serde.deserialize_payload","text":"deserialize_payload(::VanillaPayloadSerde, data, from)\n\nDeserialize data with the VanillaPayloadSerde where only basic  deserialization is applied.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#QuantizedPayloadSerde","page":"Payloads","title":"QuantizedPayloadSerde","text":"","category":"section"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"QuantizedPayloadSerde\nQPayload\nserialize_payload(::QuantizedPayloadSerde, ::Vector{Float32})\ndeserialize_payload(::QuantizedPayloadSerde, ::Vector{UInt8}, ::String)","category":"page"},{"location":"serde/payloads/#Fed.Serde.QuantizedPayloadSerde","page":"Payloads","title":"Fed.Serde.QuantizedPayloadSerde","text":"QuantizedPayloadSerde{T <: Unsigned}() <: PayloadSerde\n\nApply quantization to the weights before serialization in order to reduce the payload size. This process is lossy, thus a loss of information is to be expected after the deserialization.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.QPayload","page":"Payloads","title":"Fed.Serde.QPayload","text":"QPayload{T <: Unsigned}(data, minval, maxval)\n\nPayload generated by the quantization compression scheme. minval and maxval are metadata fields required to efficiently quantize and dequantize.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.serialize_payload-Tuple{Fed.Serde.QuantizedPayloadSerde,Array{Float32,1}}","page":"Payloads","title":"Fed.Serde.serialize_payload","text":"serialize_payload(payload_serde::PayloadSerde, weights::Vector{Float32})\n\nSerialize weights by applying the transformation defined by the  payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\nserialize_payload(::QuantizedPayloadSerde, weights)\n\nSerialize weights with the QuantizedPayloadSerde where quantization is  applied before serialization.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#Fed.Serde.deserialize_payload-Tuple{Fed.Serde.QuantizedPayloadSerde,Array{UInt8,1},String}","page":"Payloads","title":"Fed.Serde.deserialize_payload","text":"deserialize_payload(payload_serde::PayloadSerde, data::Vector{UInt8}, from::String)\n\nDeserialize data by applying the inverse transformation of the serialization process. from is the URL from which the data are coming, which may be an empty string if unused by the payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\ndeserialize_payload(::QuantizedPayloadSerde, data, from)\n\nDeserializes data with the QuantizedPayloadSerde where dequantization is applied after deserialization.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#QDiffPayloadSerde","page":"Payloads","title":"QDiffPayloadSerde","text":"","category":"section"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"QDiffPayloadSerde\nQDiffPayload\nserialize_payload(::QDiffPayloadSerde, ::Vector{Float32})\ndeserialize_payload(::QDiffPayloadSerde, ::Vector{UInt8}, ::String)","category":"page"},{"location":"serde/payloads/#Fed.Serde.QDiffPayloadSerde","page":"Payloads","title":"Fed.Serde.QDiffPayloadSerde","text":"QDiffPayloadSerde{T <: Unsigned}(chunksize::Int, is_client::Bool) <: PayloadSerde\n\nApply both quantization and diff-deduplication to the weights before serialization in order to compress the payload. Quantization is a lossy process, thus a loss of information is to be expected after deserialization.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.QDiffPayload","page":"Payloads","title":"Fed.Serde.QDiffPayload","text":"QDiffPayload{T <: Unsigned}(data, minval, maxval)\n\nPayload generated by the quantization compression scheme. Data are structured in a different way than QPayload in order to diff-deduplicate the client-side payloads by chunks.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.serialize_payload-Tuple{Fed.Serde.QDiffPayloadSerde,Array{Float32,1}}","page":"Payloads","title":"Fed.Serde.serialize_payload","text":"serialize_payload(payload_serde::PayloadSerde, weights::Vector{Float32})\n\nSerialize weights by applying the transformation defined by the  payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\nserialize_payload(::QDiffPayloadSerde, weights)\n\nSerialize weights with the QuantizedDedupPayloadSerde where quantization  and diff-deduplication of values are applied before serialization.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#Fed.Serde.deserialize_payload-Tuple{Fed.Serde.QDiffPayloadSerde,Array{UInt8,1},String}","page":"Payloads","title":"Fed.Serde.deserialize_payload","text":"deserialize_payload(payload_serde::PayloadSerde, data::Vector{UInt8}, from::String)\n\nDeserialize data by applying the inverse transformation of the serialization process. from is the URL from which the data are coming, which may be an empty string if unused by the payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\ndeserialize_payload(::QuantizedDedupPayloadSerde, data, from)\n\nDeserialize data with the QuantizedDedupPayloadSerde where regeneration of deduplicated values and dequantizatoin are applied after deserialization.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#GDPayloadSerde","page":"Payloads","title":"GDPayloadSerde","text":"","category":"section"},{"location":"serde/payloads/","page":"Payloads","title":"Payloads","text":"GDPayloadSerde\nGDPayload\nserialize_payload(::GDPayloadSerde, ::Vector{Float32})\ndeserialize_payload(::GDPayloadSerde, ::Vector{UInt8}, ::String)","category":"page"},{"location":"serde/payloads/#Fed.Serde.GDPayloadSerde","page":"Payloads","title":"Fed.Serde.GDPayloadSerde","text":"GDPayloadSerde(chunksize, fingerprint, msbsize, store_host, store_port, is_client)\n\nApply both quantization and GD to the weights before serialization in order to compress the payload. Quantization is a lossy process, thus a loss of  information is to be expected after deserialization. Depending on the chosen fingerprint, collisions can occur, also leading to a loss of information.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.GDPayload","page":"Payloads","title":"Fed.Serde.GDPayload","text":"GDPayload(data, minval, maxval)\n\nPayload generated by the GD compression. Since the GD compression scheme is built on top of quantization, the same metadata are presnts, while the structure of the data is under the form of a small GDFile.\n\n\n\n\n\n","category":"type"},{"location":"serde/payloads/#Fed.Serde.serialize_payload-Tuple{Fed.Serde.GDPayloadSerde,Array{Float32,1}}","page":"Payloads","title":"Fed.Serde.serialize_payload","text":"serialize_payload(payload_serde::PayloadSerde, weights::Vector{Float32})\n\nSerialize weights by applying the transformation defined by the  payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\nserialize_payload(::GDPayloadSerde, weights)\n\nSerialize weights with the GDPayloadSerde where quantization and generalized deduplication are applied before serialization.\n\n\n\n\n\n","category":"method"},{"location":"serde/payloads/#Fed.Serde.deserialize_payload-Tuple{Fed.Serde.GDPayloadSerde,Array{UInt8,1},String}","page":"Payloads","title":"Fed.Serde.deserialize_payload","text":"deserialize_payload(payload_serde::PayloadSerde, data::Vector{UInt8}, from::String)\n\nDeserialize data by applying the inverse transformation of the serialization process. from is the URL from which the data are coming, which may be an empty string if unused by the payload_serde.\n\ninfo: Info\nThis method is an interface to implement when creating a new PayloadSerde.\n\n\n\n\n\ndeserialize_payload(GDPayloadSerde, data, from)\n\nDeserialize data with the GDPayloadSerde where generalized deduplication and dequantization are applied before deserialization.\n\n\n\n\n\n","category":"method"},{"location":"serde/tools/#Tools","page":"Tools","title":"Tools","text":"","category":"section"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"CurrentModule = Fed.Serde","category":"page"},{"location":"serde/tools/#Packing","page":"Tools","title":"Packing","text":"","category":"section"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"Tools which ease the the weights (de)serialization.","category":"page"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"pack\nunpack","category":"page"},{"location":"serde/tools/#Fed.Serde.pack","page":"Tools","title":"Fed.Serde.pack","text":"pack(data)\n\nUtility function to serialize data into a byte array.\n\n\n\n\n\n","category":"function"},{"location":"serde/tools/#Fed.Serde.unpack","page":"Tools","title":"Fed.Serde.unpack","text":"unpack(bytes)\n\nUtility function to deserialize bytes into its original representation.\n\n\n\n\n\n","category":"function"},{"location":"serde/tools/#Quantizer","page":"Tools","title":"Quantizer","text":"","category":"section"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"Tools to (de)quantize a vector of values.","category":"page"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"Quantizer\nQuantizer(::Float32, ::Float32)\nQuantizer(::Vector{Float32})\nquantize\ndequantize","category":"page"},{"location":"serde/tools/#Fed.Serde.Quantizer","page":"Tools","title":"Fed.Serde.Quantizer","text":"Quantizer{T <: Unsigned}\n\nApply value quantization by scaling it down from one type to another, which requires less bits than the original type.\n\n\n\n\n\n","category":"type"},{"location":"serde/tools/#Fed.Serde.Quantizer-Tuple{Float32,Float32}","page":"Tools","title":"Fed.Serde.Quantizer","text":"Quantizer{T}(minval, maxval)\n\nCreate a new Quantizer which can quantize values from the range [minval, maxval].\n\n\n\n\n\n","category":"method"},{"location":"serde/tools/#Fed.Serde.Quantizer-Tuple{Array{Float32,1}}","page":"Tools","title":"Fed.Serde.Quantizer","text":"Quantizer{T}(data::Vector{Float32})\n\nCreate a new Quantizer for the given data.\n\n\n\n\n\n","category":"method"},{"location":"serde/tools/#Fed.Serde.quantize","page":"Tools","title":"Fed.Serde.quantize","text":"quantize(q::Quantizer{T}, x) where T <: Unsigned\n\nQuantize x with the Quantizer q.\n\n\n\n\n\n","category":"function"},{"location":"serde/tools/#Fed.Serde.dequantize","page":"Tools","title":"Fed.Serde.dequantize","text":"dequantize(q::Quantizer, x)\n\nDequantize x with the Quantizer q.\n\n\n\n\n\n","category":"function"},{"location":"serde/tools/#Delta-compressor","page":"Tools","title":"Delta compressor","text":"","category":"section"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"Expose a generic diff and patch mechanism to remove redundant elements from a Vector.","category":"page"},{"location":"serde/tools/","page":"Tools","title":"Tools","text":"Patch\ndiff\npatch","category":"page"},{"location":"serde/tools/#Fed.Serde.Patch","page":"Tools","title":"Fed.Serde.Patch","text":"Patch{T <: Any}\n\nData structure which contains the diff between two Vector. The second Vector can then be rebuilt by patching the first one with the Patch.\n\n\n\n\n\n","category":"type"},{"location":"serde/tools/#Fed.Serde.diff","page":"Tools","title":"Fed.Serde.diff","text":"diff(old::Vector{T}, new::Vector{T}, sizeof_T::Int)\n\nGenerate a Patch by delta compressing the difference between old and new.\n\n\n\n\n\n","category":"function"},{"location":"serde/tools/#Fed.Serde.patch","page":"Tools","title":"Fed.Serde.patch","text":"patch(old::Vector{T}, patch::Patch{T})\n\nApply patch to old.\n\n\n\n\n\n","category":"function"},{"location":"#Fed.jl","page":"Home","title":"Fed.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Fed.jl is a framework-agnostic federated learning platform developed with flexibility of configuration and extensibility in mind. The library does not target a production environment, but rather aims to facilitate research in the field of federated learning. In particular, network traffic compression.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In summary, the platform leverages a client/server architecture where a central server and multiple nodes communicate through HTTP APIs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nCurrently, Fed.jl does not offer any mechanics to handle disconnection or unavailable client/server. Thus, the server needs to be started first, and we assume every registered node to be always available.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The server has to be launched first, and will wait on the clients before starting the training. The minimum number of clients that need to join before the server starts sending requests is specified in its BaseConfig.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Fed\n\n# server url\nhost = \"127.0.0.1\"\nport = 8080\nserverurl = \"http://\" * host * \":\" * string(port)\n\nnum_comm_round = 100\nfraction_clients = 0.1f0\n# the server will wait until 100 clients have joined to start the training\nnum_total_clients = 100\n\n# setup the base config used for the federated training\nbase_config = BaseConfig(\n    serverurl,\n    num_comm_round,\n    fraction_clients,\n    num_total_clients\n)\n\n# pick a configuration (in this case, no compresison is applied)\nconfig = Fed.Config.VanillaConfig(base_config)\n\n# fake flatten parameters we want to train\nweights = rand(Flaot32, 1000)\n\n# pick an aggregation strategy\nstrategy = Fed.Server.federated_averaging\n\n# proxied function to evaluate the global model. We need to define this function\n# ousrself as its logic depend on the framework used.\neval_proxy = evaluate(weights)\n\n# instanciate the server\ncentral_node = Fed.Server.CentralNode(\n    host,\n    port,\n    weights,\n    strategy,\n    eval_proxy,\n    config\n)\n\n# finally, start the server\n@info \"Server started on [http://$host:$port]\"\nFed.Server.start(central_node)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once the server is up and running, we can start to launch clients which will register themselves to the server.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# client url\nhost = \"127.0.0.1\"\nport = 8081\n\n# Be sure to define the same config as the one used by the server as this is \n# where is specified the compression scheme used for communication.\nconfig = Fed.Config.VanillaConfig(base_config)\n\n# proxied function to train the local model (training loop). We need to define\n# this function ousrself as its logic depend on the framework used.\ntrain_proxy = fit(weights)\n\n# instanciate the client\nnode = Fed.Client.Node(host, port, train_proxy, config)\n\n# finally, start the client\n@info \"Client started on [http://$host:$port]\"\nFed.Client.start(node)","category":"page"},{"location":"#Available-configurations-for-compression","page":"Home","title":"Available configurations for compression","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the example above, we used a VanillaConfig which applies no compression. However, there are other configuration with different compression schemes which can be applied to reduce the communication cost. Their specifications are described in Serde.","category":"page"},{"location":"","page":"Home","title":"Home","text":"VanillaConfig: Classic serialization, without any compression\nQuantizedConfig: Lossy compression where the weights are quantized on UInt8\nQDiffConfig: Quantization + delta compression, only applicable for the server downlink\nGDConfig: Quantization + Generalized Deduplication (through GD.jl)","category":"page"},{"location":"config/#Config","page":"Config","title":"Config","text":"","category":"section"},{"location":"config/","page":"Config","title":"Config","text":"CurrentModule = Fed.Config","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"This module exposes the pre-configurations of the Payloads implementations. Each configuration contains the instance of the related payload. In this way, it is easy to make sure the CentralNode and the Node are using the same compression scheme. ","category":"page"},{"location":"config/","page":"Config","title":"Config","text":"Configuration","category":"page"},{"location":"config/#Fed.Config.Configuration","page":"Config","title":"Fed.Config.Configuration","text":"Configuration\n\nInterface used by the CentralNode and the Node to work with any  configuration.\n\n\n\n\n\n","category":"type"},{"location":"config/#BaseConfig","page":"Config","title":"BaseConfig","text":"","category":"section"},{"location":"config/","page":"Config","title":"Config","text":"BaseConfig","category":"page"},{"location":"config/#Fed.Config.BaseConfig","page":"Config","title":"Fed.Config.BaseConfig","text":"BaseConfig(\n    serverurl::String,\n    num_comm_rounds::Int,\n    fraction_clients::Float32,\n    num_total_clients::Int\n)\n\nPart of the configuration which are common to any type of configuration.\n\n\n\n\n\n","category":"type"},{"location":"config/#VanillaConfig","page":"Config","title":"VanillaConfig","text":"","category":"section"},{"location":"config/","page":"Config","title":"Config","text":"VanillaConfig","category":"page"},{"location":"config/#Fed.Config.VanillaConfig","page":"Config","title":"Fed.Config.VanillaConfig","text":"VanillaConfig(base::BaseConfig) <: Configuration\n\nConfiguration for the baseline, where no compression is applied. The raw data are sent over the network. This configuration instanciates a  VanillaPayloadSerde.\n\n\n\n\n\n","category":"type"},{"location":"config/#QuantizedConfig","page":"Config","title":"QuantizedConfig","text":"","category":"section"},{"location":"config/","page":"Config","title":"Config","text":"QuantizedConfig","category":"page"},{"location":"config/#Fed.Config.QuantizedConfig","page":"Config","title":"Fed.Config.QuantizedConfig","text":"QuantizedConfig{T <: Unsigned}(base::BaseConfig) <: Configuration\n\nConfiguration for compression through quantization. The quantization type needs to be speficied when the configuration is instanciated. This configuration instanciates a  QuantizedPayloadSerde.\n\n\n\n\n\n","category":"type"},{"location":"config/#QDiffConfig","page":"Config","title":"QDiffConfig","text":"","category":"section"},{"location":"config/","page":"Config","title":"Config","text":"QDiffConfig","category":"page"},{"location":"config/#Fed.Config.QDiffConfig","page":"Config","title":"Fed.Config.QDiffConfig","text":"QDiffConfig{T <: Unsigned}(\n    base::BaseConfig,\n    chunksize::Int,\n    is_client::Bool\n) <: Configuration\n\nApply the same quantization algorithm used by QuantizedConfig, but also further reduces the size of the paylaod by adding client-side \"diff- deduplication\", where unchanged chunks of data are not sent back to the server. This configuration instanciates a QDiffPayloadSerde.\n\n\n\n\n\n","category":"type"},{"location":"config/#GDConfig","page":"Config","title":"GDConfig","text":"","category":"section"},{"location":"config/","page":"Config","title":"Config","text":"GDConfig","category":"page"},{"location":"config/#Fed.Config.GDConfig","page":"Config","title":"Fed.Config.GDConfig","text":"GDConfig{T <: Unsigned}(\n    base::BaseConfig,\n    chunksize::Int,\n    fingerprint::Function,\n    msbsize::T,\n    store_host::String,\n    store_port::Int,\n    is_client::Bool\n) <: Configuration\n\nCompress the payload by using a GD Store, producing a generally deduplicated GDFile which are exchanged between the clients and the server. This  configuration instanciates a GDPayloadSerde and is making use of the GD.jl library to handle the generalized deduplication logic.\n\n\n\n\n\n","category":"type"}]
}
